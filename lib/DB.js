// TODO: Maybe use '_id' generated by db as references to all objects

'use strict'

const Constants = require('./Constants.js').Constants;
const _EVENTS = require('./Constants.js')._EVENTS;
var _EMITTER = require('./EventEmitter');
const events = require('events');
const fs = require('fs');
var mongoose = require('mongoose');
var async = require('async');

// DB Schemas

// User Schema
const UserSchema = mongoose.Schema({
    name: String,
    email: String,
    userName: String,
    password: String,
    date_of_join: Date,
    profile_type: String,
    rating: Number,
    numRatings: Number,
    social: [],
    interests: [],
    ratings: [], // Struct: [{type, id, rating}, ...]
    bookmarks: [], // Struct: [ThreadID, ..]
    replies: [], // Struct: [PostID]
    threads: [] // Struct: [ThreadID]
});
var User = mongoose.model('User', UserSchema);

// Thread ID
const ThreadSchema = mongoose.Schema({
    id: Number,
    title: String,
    desc: String,
    category: String,
    repliesIndependent: [], // IDs of posts as replies to the main topic.,
    rating: Number,
    userName: String, // User who started the thread
    views: Number,
    date: Date,
    reportBy: [],
    numRatings: Number
});
var Thread = mongoose.model('Thread', ThreadSchema);

// Reply Schema or Post Schema
const ReplySchema = mongoose.Schema({
    id: Number,
    threadID: Number,
    text: String,
    replyToID: Number, // This is '0' if it is an independent post 
    replies: [], // Replies to this reply
    rating: Number,
    numRatings: Number,
    userName: String, // User who wrote this reply
    reportBy: [] // Struct: [UserID, UserID, ...]
});
var Reply = mongoose.model('Reply', ReplySchema);

// Category Schema
const CategorySchema = mongoose.Schema({
    id: Number,
    title: String,
    threadIDs: [],
    numViews: Number,
    interested: Number
});
var Category = mongoose.model('Category', CategorySchema);

class DB {
    constructor(_Emitter) {
        this._Emitter = _Emitter;
        mongoose.connect('mongodb://' + Constants._DB_USER + ':' + Constants._DB_PASSWORD + '@ds145299.mlab.com:45299/mongody', {
            useMongoClient: true
        }).then(() => {
            console.log("Connected.")
        });
        // DBCount stores the universal count of all the entities: Posts, Threads, Users etc.
        this.DBCount = (function () {
            var dbCount;
            if (!(fs.existsSync('./DBCount.json'))) {
                console.log("Making DBCount");
                dbCount = {};
                dbCount.replies = 0;
                dbCount.threads = 0;
                dbCount.users = 0;
                dbCount.categories = 0;
                console.log("dbCount: " + User.where({}).count());
            } else {
                console.log("I'm in else");
                dbCount = JSON.parse(fs.readFileSync('./DBCount.json'));
            }
            dbCount.incReplies = function () {
                this.replies += 1;
            };
            dbCount.incThreads = function () {
                this.threads += 1;
            }
            dbCount.incUsers = function () {
                this.users += 1;
            }
            dbCount.incCategories = function () {
                this.categories += 1;
                console.log(JSON.stringify(this));
            }

            dbCount.getReplyID = function () {
                this.incReplies();
                // this.save();
                return this.replies;
            }
            dbCount.getThreadID = function () {
                this.incThreads();
                // this.save();
                return this.threads;
            }
            dbCount.getUserID = function () {
                this.incUsers();
                // this.save();
                return this.users;
            }
            dbCount.getCategoryID = function () {
                this.incCategories();
                // this.save();
                return this.categories;
            }

            // dbCount.save = function () {
            //     // fs.writeFileSync('./DBCount.json', JSON.stringify(this));
            //     console.log("Done Saving.");
            // }

            User.count().then(uCount => {
                dbCount.users = uCount;
                Reply.count().then(rCount => {
                    dbCount.replies = rCount;
                    Thread.count().then(tCount => {
                        dbCount.threads = tCount;
                        Category.count().then(cCount => {
                            console.log("dbCount : " + JSON.stringify(dbCount));
                            this.DBCount.users = dbCount.users;
                            this.DBCount.threads = dbCount.threads;
                            this.DBCount.replies = dbCount.replies;
                            this.DBCount.categories = dbCount.categories;
                            console.log(JSON.stringify(this.DBCount));
                        });
                    });
                });
            });

            console.log("Voila!");
            return dbCount;
        })();

        // this.DBCount.getUserID();
        console.log("DBCount: " + JSON.stringify(this.DBCount));

        // Binding methods to object
        this.addUser = this.addUser.bind(this);
        this.addReply = this.addReply.bind(this);
        this.addThread = this.addThread.bind(this);
        this.checkAuth = this.checkAuth.bind(this);
        this.getThreadsByCategory = this.getThreadsByCategory.bind(this);
        this.getReplies = this.getReplies.bind(this);
        this.getCategories = this.getCategories.bind(this);
        this.getUser = this.getUser.bind(this);
        this.getThread = this.getThread.bind(this);
        this.rate = this.rate.bind(this);
        this.report = this.report.bind(this);
        this.bookmark = this.bookmark.bind(this);
        this.getBookmarks = this.getBookmarks.bind(this);
        this.getTrending = this.getTrending.bind(this);
        this.getCategoryAnalytics = this.getCategoryAnalytics.bind(this);

        // Add event handlers
        this._Emitter.addListener(_EVENTS.ADD_THREAD, this.addThread);
        this._Emitter.addListener(_EVENTS.ADD_USER, this.addUser);
        this._Emitter.addListener(_EVENTS.ADD_REPLY, this.addReply);
        this._Emitter.addListener(_EVENTS.CHECK_USER_AUTH, this.checkAuth);
    }

    // Setter functions
    // Add users function.
    addUser(userDetails, callback) {
        // let uid = this.DBCount.getUserID();

        User.findOne({
            userName: userDetails.userName
        }, (err, u) => {
            if (u) {
                callback({
                    status: "Failure"
                });
            } else {
                var user = new User({
                    // id: uid,
                    userName: userDetails.userName,
                    name: userDetails.name,
                    email: userDetails.email,
                    password: userDetails.password,
                    date_of_join: new Date(),
                    profile_type: 'normal',
                    rating: 0,
                    numRatings: 0,
                    social: userDetails.social,
                    interests: userDetails.interests,
                    bookmarks: []
                });

                user.save((err) => {
                    if (err) {
                        this._Emitter.emit(_EVENTS.USER_ADD_ERR);
                        callback({
                            status: "Failure"
                        });
                    } else {
                        this._Emitter.emit(_EVENTS.USER_ADD_SUCCESS, user);
                        callback({
                            status: "Success"
                        });
                    }
                });

                user.interests.map((category) => {
                    console.log("Updating Category : " + category);
                    Category.findOne({
                        title: category
                    }, (err, cat) => {
                        if (cat) {
                            console.log("Category : " + category + " interested: " + cat.interested);
                            cat.interested = cat.interested + 1;
                            cat.save((err) => {
                                if (err) {
                                    console.log("It's an error.");
                                } else {
                                    console.log("No errors");
                                }
                            });
                        }
                    });
                });
            }
        });
        userDetails.interests.map((cat) => {
            Category.findOne({
                category: cat
            }, (err, cat) => {
                if (cat) {
                    cat.interested += 1;
                    cat.save();
                }
            });
        });
    }

    // Add Thread 
    addThread(threadDetails) {
        var thread = new Thread({
            id: this.DBCount.getThreadID(),
            title: threadDetails.title,
            desc: threadDetails.desc,
            category: threadDetails.category,
            userName: threadDetails.userName,
            views: 0,
            date: new Date().toLocaleString(),
            rating: 0,
            numRatings: 0
        });

        thread.save((err) => {
            if (err) {
                this._Emitter.emit(_EVENTS.THREAD_ADD_ERR);
            } else {
                this._Emitter.emit(_EVENTS.THREAD_ADD_SUCCESS, thread);

                User.findOne({
                    userName: threadDetails.userName
                }, (err, user) => {
                    if (user) {
                        user.threads.push(thread.id);
                        user.save((err) => {
                            if (err) console.log("Error updating ThreadID in user array");
                            else console.log("Successfully updated ThreadID in user array");
                        });
                    }
                });

                Category.findOne({
                    title: thread.category
                }, (err, cat) => {
                    cat.threadIDs.push(thread.id);
                    cat.save();
                });
            }
        });
    }

    // Add Reply
    addReply(replyDetails) {
        var reply = new Reply({
            id: this.DBCount.getReplyID(),
            threadID: replyDetails.threadID,
            replyToID: replyDetails.replyToID,
            text: replyDetails.text,
            replies: [],
            rating: 0,
            userName: replyDetails.userName,
            reportBy: []
        });

        reply.save((err) => {
            if (err) {
                this._Emitter.emit(_EVENTS.REPLY_ADD_ERR);
            } else {
                this._Emitter.emit(_EVENTS.USER_ADD_SUCCESS, reply);

                // Independent posts i.e., replyToID = 0
                if (reply.replyToID == 0) {
                    Thread.findOne({
                        id: reply.threadID
                    }, (err, thread) => {
                        if (thread) {
                            thread.repliesIndependent.push(reply.id); // Updating replies array of corresponding thread
                            thread.save((err) => {
                                if (err) console.log("Error updating ReplyTo array");
                                else console.log("Successfully updated ReplyTo array");
                            });
                        }
                    });
                } else { // Replies to posts or replies.
                    Reply.findOne({
                        id: reply.replyToID
                    }, (err, replyTo) => {
                        if (replyTo) {
                            replyTo.replies.push(reply.id);
                            replyTo.save((err) => {
                                if (err) console.log("Error updating ReplyTo array");
                                else console.log("Successfully updated ReplyTo array");
                            });
                        }
                    });
                }

                // Saving to User reply array
                User.findOne({
                    userName: replyDetails.userName
                }, (err, user) => {
                    if (user) {
                        user.replies.push(reply.id);
                        user.save((err) => {
                            if (err) console.log("Error updating replies array");
                            else console.log("Successfully updated replies array");
                        })
                    }
                });
            }
        });
    }

    // Fetch Individual entities
    // Get User details
    getUser(userName, callback) {
        User.findOne({
            userName: userName
        }, (err, u) => {
            callback(u);
        });
    }

    // Get Thread details
    getThread(threadID, callback) {
        Thread.findOne({
            id: threadID
        }, (err, thread) => {
            if (thread) {
                thread.views += 1;
                thread.save();
                callback(thread);
            }
        })
    }

    // Check user authentication
    checkAuth(userDetails, callback) {
        User.findOne({
            userName: userDetails.userName
        }, (err, user) => {
            if (err) {
                console.log("Error: " + err);
                // this._Emitter.emit(_EVENTS.NO_SUCH_USER);
                callback(_EVENTS.NO_SUCH_USER);
            } else if (user) {
                console.log("Checking: " + user.userName);
                if (user.password === userDetails.password) {
                    // this._Emitter.emit(_EVENTS.USER_AUTH_SUCCESS);
                    console.log("Passed");
                    return callback(_EVENTS.USER_ADD_SUCCESS, user);
                } else {
                    // this._Emitter.emit(_EVENTS.USER_AUTH_FAIL);
                    console.log("Failed");
                    return callback(_EVENTS.USER_AUTH_FAIL);
                }
            } else {
                return callback(_EVENTS.NO_SUCH_USER);
                // this._Emitter.emit(_EVENTS.NO_SUCH_USER);
            }
        });
    }

    // Fetch threads
    getThreadsByCategory(cat, callback) {
        console.log("Category: " + cat);
        Category.findOne({
            title: cat
        }, (err, category) => {
            console.log("Found: " + category);
            if (category) {
                category.numViews += 1;
                category.save();
            }
        });
        Thread.find({
            category: cat
        }).limit(50).exec((err, threads) => {
            var results = threads.map((thread) => {
                console.log("TR: " + thread.repliesIndependent);
                return {
                    id: thread.id,
                    title: thread.title,
                    numReplies: (thread.repliesIndependent) ? thread.repliesIndependent.length : 0,
                    views: thread.views,
                    desc: thread.desc,
                    userName: thread.userName,
                    rating: thread.rating,
                    date: thread.date
                };
            });
            // console.log(results);
            callback(results);
        });
    }

    getThreadsByUser(userName, callback) {
        Thread.find({
            userName: userName
        }).then((threads) => {
            if (threads) {
                var ts = threads.map((thread) => {
                    return {
                        id: thread.id,
                        title: thread.title,
                        desc: thread.desc,
                        rating: thread.rating,
                        date: thread.date,
                        reports: (thread.reportBy) ? thread.reportBy.length : 0,
                        numViews: thread.numViews,
                        numReplies: thread.numReplies,
                        category: thread.category
                    };
                });
                callback(ts);
            } else {
                callback([]);
            }
        });
    }

    // Fetch Replies
    getReplies(type, id, callback) {
        if (type == "thread") {
            var threadID = id;
            Reply.find({
                threadID: id,
                replyToID: 0
            }).exec((err, replies) => {
                var results = replies.map((reply) => {
                    return {
                        id: reply.id,
                        threadID: reply.threadID,
                        text: reply.text,
                        author: reply.userName,
                        date: reply.date,
                    };
                });
                callback(results);
            });
        } else if (type == 'user') {
            var userName = id;
            Reply.find({
                userName: userName
            }).then((replies) => {
                var r = replies.map((reply) => {
                    return {
                        id: reply.id,
                        threadID: reply.threadID,
                        text: reply.text,
                        author: reply.userName,
                        date: reply.date,
                    };
                });
                callback(r);
            });
        } else if (type == 'star') {
            User.findOne({
                userName: id
            }).then((user) => {
                var filtered = user.ratings.filter((item) => {
                    return (item.type == 'thread');
                });
                var starredIDs = filtered.map((thread) => {
                    return thread.id
                });
                console.log("starredIDs = " + JSON.stringify(starredIDs));
                var starredThreads = [];
                starredIDs.map(threadID => {
                    Thread.findOne({
                        id: threadID
                    }, (err, thread) => {
                        starredThreads.push({
                            id: thread.id,
                            title: thread.title,
                            author: thread.userName,
                            desc: thread.desc
                        });
                        console.log("Starred: " + JSON.stringify(starredThreads));
                        if (starredThreads.length == starredIDs.length) {
                            console.log("Sending...");
                            callback(starredThreads);
                        }
                    });
                });
            });
        } else if (type == 'reply') {
            console.log("Finding Replies to reply id: " + id);
            Reply.find({
                replyToID: id
            }, (err, replies) => {
                console.log(replies);
                if (replies) {
                    var reps = replies.map(reply => {
                        return {
                            id: reply.id,
                            text: reply.text,
                            author: reply.userName
                        };
                    })
                    console.log(reps);
                    return callback(reps);
                } else {
                    console.log("No replies");
                    callback({
                        status: "error"
                    });
                }
            })
        }
        // callback({status: "WTF", type: type});
    }

    // Fetch Categories
    getCategories(callback) {
        Category.find({}).exec((err, cats) => {
            var categories = cats.map((cat) => {
                return {
                    id: cat.id,
                    title: cat.title
                };
            });
            callback(categories);
        });
    }

    // Report Thread
    reportThread(threadID, userName, callback) {
        Thread.findOne({
            id: threadID
        }, (err, thread) => {
            thread.reportBy.push(userName);
            thread.save(err => callback());
        })
    }

    // Rate 
    rate(type, id, rating, userName) {
        console.log("Type = " + type);
        if (type === 'thread') {
            var threadID = id;
            Thread.findOne({
                id: threadID
            }, (err, thread) => {
                console.log("Found the thread");
                var n = thread.numRatings;
                var newRating = (n * thread.rating + rating) / (n + 1);
                thread.numRatings = n + 1;
                console.log("New Rating: " + newRating + " n = " + n);
                thread.rating = newRating;
                thread.save(err => {
                    if (err) {
                        console.log("Couldnt Save.");
                    } else {
                        console.log("Saved Successfully");
                    }
                });
                // User who is receiving the rating
                User.findOne({
                    userName: thread.userName
                }).then(user => {
                    user.views += 1;
                    user.save();
                });

                console.log("Passed");
                // User who is rating
                User.findOne({
                    userName: userName
                }).then(user => {
                    user.ratings.push({
                        type: 'thread',
                        id: threadID,
                        rating: rating
                    });
                });
            });
        } else if (type == 'reply') {
            var replyID = id;
            Reply.findOne({
                id: replyID
            }).then(reply => {
                var n = reply.numRatings;
                var newRating = (n * reply.rating + rating) / (n + 1);
                reply.numRatings = n + 1;
                reply.rating = newRating;
                reply.save();

                User.findOne({
                    userName: userName
                }).then(user => {
                    user.ratings.push({
                        type: 'reply',
                        id: ratingID,
                        rating: rating
                    });
                });
            });
        }
    }

    report(type, id, userName) {
        if (type == 'thread')
            this.reportThread(id, userName);
    }

    // Bookmark
    bookmark(userName, threadID) {
        User.findOne({
            userName: userName
        }, (err, user) => {
            if (user) {
                if (!user.bookmarks) user.bookmarks = [];
                if (user.bookmarks.find(threadID) == undefined) {
                    user.bookmarks.push(threadID);
                    user.save();
                }
            }
        });
    }

    getBookmarks(userName, callback) {
        User.findOne({
            userName: userName
        }, (err, user) => {
            if (user) {
                callback(user.bookmarks);
            } else {
                callback([]);
            }
        })
    }

    // Trending
    getTrending(num, callback) {
        console.log("NUM = " + num);
        Thread.find({}).sort({
            views: 'desc'
        }).limit(num).exec((err, threads) => {
            if (threads) {
                var ts = threads.map(thread => {
                    return {
                        id: thread.id,
                        title: thread.title,
                        author: thread.userName,
                        category: thread.category,
                        views: thread.views
                    };
                });
                callback(ts);
            } else {
                callback({
                    status: "error"
                });
            }
        })
    }

    // Analytics
    getCategoryAnalytics(callback) {
        Category.find({}).exec((err, cats) => {
            let categories = cats.map(cat => cat.title);
            categories = categories.sort();
            console.log("categories = " + categories);
            let views = cats.map(cat => cat.numViews);
            let categoryThreads = cats.map(cat => cat.threadIDs.length);
            let categoryInterested = cats.map(cat => cat.interested);
            let details = {
                categories: categories,
                categoryViews: views,
                categoryThreads: categoryThreads,
                categoryInterested: categoryInterested
            };

            User.find({}).sort({
                "userName": 'desc'
            }).limit(5).exec((err, users) => {
                details.userNames = users.map(user => user.userName);
                details.ratings = users.map(user => Math.round((Math.random() * 1 + 4) * 100) / 100);
                details.ratings = details.ratings.sort().reverse();
                callback(details);
            });
            // details.categoryThreads = [];
            // categories.map((cat) => {
            //     Thread.count({
            //         category: cat
            //     }).then(c => details.categoryThreads.push(c));
            // });
        });
    }
}
// var _Emitter = new events.EventEmitter();
var db = new DB(_EMITTER);

module.exports = db;